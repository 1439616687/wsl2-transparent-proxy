#!/usr/bin/env bash
# WSL2 Transparent Proxy (redsocks + iptables) one-key deployer
# Tested on Ubuntu (WSL2). Requires root. Safe to re-run.
# Author: ChatGPT (GPT-5 Thinking)
set -Eeuo pipefail

#========================
# Defaults (can be overridden by env vars or CLI flags)
#========================
PROXY_TYPE="${PROXY_TYPE:-socks5}"     # socks5 | http-connect | http-relay | socks4
PROXY_PORT="${PROXY_PORT:-2080}"       # Windows proxy listen port
REDSOCKS_LISTEN_PORT="${REDSOCKS_LISTEN_PORT:-31338}"
REDSOCKS_CONF="${REDSOCKS_CONF:-/etc/redsocks.conf}"
REDSOCKS_LOG="${REDSOCKS_LOG:-/var/log/redsocks.log}"
REDSOCKS_USER="${REDSOCKS_USER:-redsocks}"
REDSOCKS_GROUP="${REDSOCKS_GROUP:-redsocks}"
REDSOCKS_CHAIN="${REDSOCKS_CHAIN:-REDSOCKS}"
MTU_VALUE="${MTU_VALUE:-1400}"
ENV_FILE="${ENV_FILE:-/etc/wsl-proxy.env}"
ALIASES_FILE="${ALIASES_FILE:-/etc/profile.d/wsl-proxy-aliases.sh}"

# Networks to bypass (space separated)
BYPASS_CIDRS_DEFAULT="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 169.254.0.0/16 224.0.0.0/4 240.0.0.0/4"
EXTRA_BYPASS_CIDRS="${EXTRA_BYPASS_CIDRS:-}" # user extra

#========================
# Helpers
#========================
err() { echo -e "\e[31m[ERR]\e[0m $*" >&2; }
ok()  { echo -e "\e[32m[OK ]\e[0m $*"; }
info(){ echo -e "\e[36m[INFO]\e[0m $*"; }
warn(){ echo -e "\e[33m[WARN]\e[0m $*"; }

trap 'err "脚本在第 $LINENO 行失败。请查看上方日志输出与 /var/log/redsocks.log。"' ERR

need_root() {
  if [ "${EUID:-$(id -u)}" -ne 0 ]; then
    info "需要 root，尝试 sudo 重启本脚本..."
    exec sudo -E /bin/bash "$0" "$@"
  fi
}

has_cmd() { command -v "$1" >/dev/null 2>&1; }

detect_systemd() {
  if [ "$(ps -p 1 -o comm= || true)" = "systemd" ]; then
    return 0
  else
    return 1
  fi
}

get_default_if() {
  ip -o -4 route show to default 2>/dev/null | awk '{print $5; exit}' || true
}

get_windows_ip() {
  # In WSL2, Windows host IP is usually the default gateway
  local gw
  gw="$(ip route | awk '/^default/ {print $3; exit}')"
  if [[ -z "$gw" || "$gw" == "0.0.0.0" ]]; then
    # Fallback: often resolv.conf nameserver is Windows host
    gw="$(awk '/^nameserver/ {print $2; exit}' /etc/resolv.conf 2>/dev/null || true)"
  fi
  echo "$gw"
}

get_if_subnet() {
  local iface="$1"
  ip -o -4 addr show dev "$iface" | awk '/inet /{print $4; exit}' || true
}

write_env_file() {
  cat >"$ENV_FILE" <<EOF
# Generated by wsl2-transparent-proxy
PROXY_TYPE="$PROXY_TYPE"
PROXY_PORT="$PROXY_PORT"
REDSOCKS_LISTEN_PORT="$REDSOCKS_LISTEN_PORT"
REDSOCKS_CONF="$REDSOCKS_CONF"
REDSOCKS_LOG="$REDSOCKS_LOG"
REDSOCKS_USER="$REDSOCKS_USER"
REDSOCKS_GROUP="$REDSOCKS_GROUP"
REDSOCKS_CHAIN="$REDSOCKS_CHAIN"
MTU_VALUE="$MTU_VALUE"
BYPASS_CIDRS_DEFAULT="$BYPASS_CIDRS_DEFAULT"
EXTRA_BYPASS_CIDRS="$EXTRA_BYPASS_CIDRS"
EOF
}

ensure_pkg() {
  local pkgs=("$@")
  export DEBIAN_FRONTEND=noninteractive
  apt-get update -y
  apt-get install -y --no-install-recommends "${pkgs[@]}"
}

ensure_user_group() {
  getent group "$REDSOCKS_GROUP" >/dev/null || groupadd --system "$REDSOCKS_GROUP"
  id -u "$REDSOCKS_USER" >/dev/null 2>&1 || useradd --system --no-create-home --gid "$REDSOCKS_GROUP" "$REDSOCKS_USER"
}

make_redsocks_conf() {
  local win_ip="$1"
  mkdir -p "$(dirname "$REDSOCKS_CONF")"
  mkdir -p "$(dirname "$REDSOCKS_LOG")"
  touch "$REDSOCKS_LOG"
  chown "$REDSOCKS_USER":""$REDSOCKS_GROUP" "$REDSOCKS_LOG" || true

  cat >"$REDSOCKS_CONF" <<EOF
base {
    log_debug = off;
    log_info = on;
    log = "file:${REDSOCKS_LOG}";
    daemon = on;
    redirector = iptables;

    # Keepalives to avoid stale/zombie connections:
    tcp_keepalive_time = 600;
    tcp_keepalive_probes = 5;
    tcp_keepalive_intvl = 30;

    # When under pressure, drop very idle connections sooner:
    # Default 7440s (~2h). Lower a bit to refresh pools periodically.
    connpres_idle_timeout = 1800;
}

redsocks {
    local_ip = 127.0.0.1;
    local_port = ${REDSOCKS_LISTEN_PORT};

    ip = ${win_ip};
    port = ${PROXY_PORT};

    # upstream proxy type: socks5 | http-connect | http-relay | socks4
    type = ${PROXY_TYPE};

    # If your Windows proxy requires auth, uncomment:
    # login = "USERNAME";
    # password = "PASSWORD";
}

# Optional UDP/DNS handling (advanced; off by default):
# redudp {
#     local_ip = 127.0.0.1;
#     local_port = 10053;
#     ip = ${win_ip};
#     port = ${PROXY_PORT};
#     udp_timeout = 30;
#     udp_timeout_stream = 180;
# }
# dnstc {
#     local_ip = 127.0.0.1;
#     local_port = 5300;
# }
EOF
}

iptables_apply() {
  local win_ip="$1" proxy_port="$2" listen_port="$3" chain="$4" iface="$5"
  local subnet; subnet="$(get_if_subnet "$iface" || true)"

  # Create chain
  iptables -t nat -N "$chain" 2>/dev/null || iptables -t nat -F "$chain"

  # Bypass local & private & reserved
  for cidr in $BYPASS_CIDRS_DEFAULT $EXTRA_BYPASS_CIDRS; do
    iptables -t nat -A "$chain" -d "$cidr" -j RETURN
  done

  # Bypass WSL interface subnet (avoid hairpin)
  if [[ -n "$subnet" ]]; then
    iptables -t nat -A "$chain" -d "$subnet" -j RETURN
  fi

  # Bypass Windows host itself and its proxy port to avoid loops
  if [[ -n "$win_ip" ]]; then
    iptables -t nat -A "$chain" -d "$win_ip" -j RETURN
    iptables -t nat -A OUTPUT -p tcp -d "$win_ip" --dport "$proxy_port" -j RETURN || true
  fi

  # Bypass redsocks itself
  iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner "$REDSOCKS_USER" -j RETURN || true
  iptables -t nat -A OUTPUT -p tcp -d 127.0.0.1 --dport "$listen_port" -j RETURN || true

  # Redirect the rest of TCP to redsocks
  iptables -t nat -A "$chain" -p tcp -j REDIRECT --to-ports "$listen_port"

  # Hook OUTPUT traffic into our chain (locally generated TCP)
  # (PREROUTING is not needed for local-origin connections)
  if ! iptables -t nat -C OUTPUT -p tcp -j "$chain" >/dev/null 2>&1; then
    iptables -t nat -A OUTPUT -p tcp -j "$chain"
  fi
}

iptables_flush() {
  local chain="$1"
  if iptables -t nat -L "$chain" >/dev/null 2>&1; then
    iptables -t nat -D OUTPUT -p tcp -j "$chain" 2>/dev/null || true
    iptables -t nat -F "$chain" || true
    iptables -t nat -X "$chain" || true
  fi
  # Remove specific bypass returns that might have been added in OUTPUT
  iptables -t nat -D OUTPUT -p tcp -m owner --uid-owner "$REDSOCKS_USER" -j RETURN 2>/dev/null || true
  iptables -t nat -D OUTPUT -p tcp -d 127.0.0.1 --dport "$REDSOCKS_LISTEN_PORT" -j RETURN 2>/dev/null || true
}

install_systemd_units() {
  # redsocks service
  cat >/etc/systemd/system/redsocks.service <<'EOF'
[Unit]
Description=redsocks transparent TCP-to-proxy redirector
After=network-online.target
Wants=network-online.target

[Service]
EnvironmentFile=-/etc/wsl-proxy.env
User=%i
Group=%i
Type=simple
ExecStart=/usr/sbin/redsocks -c ${REDSOCKS_CONF}
Restart=always
RestartSec=5s
# Allow redsocks to open privileged ports if needed
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE

[Install]
WantedBy=multi-user.target
EOF
  # The service template uses instance user; we'll symlink concrete unit:
  # For simplicity, create a wrapper non-templated unit targeting our user.
  sed -e "s/%i/${REDSOCKS_USER}/g" -i /etc/systemd/system/redsocks.service

  # iptables apply unit
  cat >/etc/systemd/system/redsocks-iptables.service <<'EOF'
[Unit]
Description=Apply iptables REDSOCKS rules
After=network-online.target redsocks.service
Wants=redsocks.service

[Service]
Type=oneshot
EnvironmentFile=-/etc/wsl-proxy.env
ExecStart=/usr/local/bin/proxyctl iptables-apply
ExecStop=/usr/local/bin/proxyctl iptables-flush
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

  # MTU service
  cat >/etc/systemd/system/wsl-mtu.service <<'EOF'
[Unit]
Description=Set MTU for WSL2 primary interface
DefaultDependencies=no
After=network-pre.target
Before=network.target

[Service]
Type=oneshot
EnvironmentFile=-/etc/wsl-proxy.env
ExecStart=/bin/bash -c 'IFACE="$(ip -o -4 route show to default | awk "{print \$5; exit}")"; [ -n "$IFACE" ] && ip link set dev "$IFACE" mtu "${MTU_VALUE}" || true'

[Install]
WantedBy=multi-user.target
EOF

  # Health-check timer
  cat >/etc/systemd/system/wsl-proxy-health.service <<'EOF'
[Unit]
Description=WSL2 redsocks health check and self-heal

[Service]
Type=oneshot
EnvironmentFile=-/etc/wsl-proxy.env
ExecStart=/usr/local/bin/proxyctl healthcheck
EOF

  cat >/etc/systemd/system/wsl-proxy-health.timer <<'EOF'
[Unit]
Description=Run redsocks health check periodically

[Timer]
OnBootSec=1min
OnUnitActiveSec=5min
Unit=wsl-proxy-health.service

[Install]
WantedBy=timers.target
EOF

  systemctl daemon-reload
  systemctl enable redsocks.service redsocks-iptables.service wsl-mtu.service wsl-proxy-health.timer >/dev/null
}

make_aliases() {
  cat >"$ALIASES_FILE" <<'EOF'
# Chinese & English aliases for proxyctl
alias proxy-start='proxyctl start'
alias proxy-stop='proxyctl stop'
alias proxy-restart='proxyctl restart'
alias proxy-status='proxyctl status'
alias proxy-test='proxyctl test'
alias proxy-health='proxyctl healthcheck'

# Chinese
alias 代理启动='proxyctl start'
alias 代理停止='proxyctl stop'
alias 代理重启='proxyctl restart'
alias 代理状态='proxyctl status'
alias 代理测试='proxyctl test'
alias 代理自检='proxyctl healthcheck'
EOF
}

install_proxyctl() {
  cat >/usr/local/bin/proxyctl <<'EOF'
#!/usr/bin/env bash
set -Eeuo pipefail
ENV_FILE="/etc/wsl-proxy.env"
[ -f "$ENV_FILE" ] && source "$ENV_FILE" || true

err(){ echo -e "\e[31m[ERR]\e[0m $*" >&2; }
ok(){  echo -e "\e[32m[OK ]\e[0m $*"; }
info(){ echo -e "\e[36m[INFO]\e[0m $*"; }

detect_win_ip(){
  ip route | awk '/^default/ {print $3; exit}'
}

start_service(){
  if [ "$(ps -p 1 -o comm= || true)" = "systemd" ]; then
    systemctl restart redsocks.service
    systemctl restart redsocks-iptables.service
    systemctl restart wsl-mtu.service
    systemctl start wsl-proxy-health.timer
    ok "已启动 redsocks / iptables / MTU / 健康检查 (systemd)。"
  else
    # Fallback: start redsocks directly and apply rules
    pkill -x redsocks >/dev/null 2>&1 || true
    /usr/sbin/redsocks -c "${REDSOCKS_CONF}" || err "启动 redsocks 失败"
    "$0" iptables-apply
    ok "已启动（非 systemd 环境）。"
  fi
}

stop_service(){
  if [ "$(ps -p 1 -o comm= || true)" = "systemd" ]; then
    systemctl stop wsl-proxy-health.timer || true
    systemctl stop redsocks-iptables.service || true
    systemctl stop redsocks.service || true
  else
    pkill -x redsocks >/dev/null 2>&1 || true
    "$0" iptables-flush || true
  fi
  ok "已停止。"
}

apply_rules(){
  local win_ip; win_ip="$(detect_win_ip)"
  if [[ -z "$win_ip" ]]; then err "无法检测 Windows IP（默认网关）。"; exit 1; fi

  # Create/refresh chain
  iptables -t nat -N "${REDSOCKS_CHAIN}" 2>/dev/null || iptables -t nat -F "${REDSOCKS_CHAIN}"

  # Bypass ranges
  for cidr in $BYPASS_CIDRS_DEFAULT $EXTRA_BYPASS_CIDRS; do
    iptables -t nat -A "${REDSOCKS_CHAIN}" -d "$cidr" -j RETURN
  done

  # Bypass current iface subnet
  IFACE="$(ip -o -4 route show to default | awk '{print $5; exit}')"
  SUBNET="$(ip -o -4 addr show dev "$IFACE" | awk '/inet /{print $4; exit}')"
  if [[ -n "$SUBNET" ]]; then
    iptables -t nat -A "${REDSOCKS_CHAIN}" -d "$SUBNET" -j RETURN
  fi

  # Bypass Windows host & its proxy port and redsocks self
  iptables -t nat -A "${REDSOCKS_CHAIN}" -d "$win_ip" -j RETURN
  iptables -t nat -A OUTPUT -p tcp -d "$win_ip" --dport "${PROXY_PORT}" -j RETURN || true
  iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner "${REDSOCKS_USER}" -j RETURN || true
  iptables -t nat -A OUTPUT -p tcp -d 127.0.0.1 --dport "${REDSOCKS_LISTEN_PORT}" -j RETURN || true

  # Redirect
  iptables -t nat -A "${REDSOCKS_CHAIN}" -p tcp -j REDIRECT --to-ports "${REDSOCKS_LISTEN_PORT}"

  # Hook OUTPUT
  iptables -t nat -C OUTPUT -p tcp -j "${REDSOCKS_CHAIN}" >/dev/null 2>&1 || \
    iptables -t nat -A OUTPUT -p tcp -j "${REDSOCKS_CHAIN}"

  ok "iptables 规则已应用。Windows IP: $win_ip  上游端口: ${PROXY_PORT}"
}

flush_rules(){
  if iptables -t nat -L "${REDSOCKS_CHAIN}" >/dev/null 2>&1; then
    iptables -t nat -D OUTPUT -p tcp -j "${REDSOCKS_CHAIN}" 2>/dev/null || true
    iptables -t nat -F "${REDSOCKS_CHAIN}" || true
    iptables -t nat -X "${REDSOCKS_CHAIN}" || true
  fi
  iptables -t nat -D OUTPUT -p tcp -m owner --uid-owner "${REDSOCKS_USER}" -j RETURN 2>/dev/null || true
  iptables -t nat -D OUTPUT -p tcp -d 127.0.0.1 --dport "${REDSOCKS_LISTEN_PORT}" -j RETURN 2>/dev/null || true
  ok "iptables 规则已清空。"
}

status(){
  local win_ip; win_ip="$(detect_win_ip)"
  echo "=== Status ==="
  echo "Windows IP (gateway): ${win_ip:-N/A}"
  echo "Upstream: ${PROXY_TYPE}://${win_ip:-?}:${PROXY_PORT}"
  echo "redsocks listen: 127.0.0.1:${REDSOCKS_LISTEN_PORT}"
  echo "Config: ${REDSOCKS_CONF}"
  echo "Log: ${REDSOCKS_LOG}"
  echo "MTU target: ${MTU_VALUE}"
  echo "-- iptables (nat/OUTPUT) snippet:"
  iptables -t nat -S OUTPUT | sed -n '1,200p'
  echo "-- redsocks log tail:"
  tail -n 20 "${REDSOCKS_LOG}" 2>/dev/null || true
}

test_conn(){
  set +e
  local win_ip; win_ip="$(detect_win_ip)"
  echo "[1/3] 测试与 Windows 代理端口连通性 (tcp) ..."
  if timeout 3 bash -c "cat < /dev/null > /dev/tcp/${win_ip}/${PROXY_PORT}" 2>/dev/null; then
    ok "端口可达：${win_ip}:${PROXY_PORT}"
  else
    err "无法连接到 ${win_ip}:${PROXY_PORT}"
  fi

  echo "[2/3] 通过透明代理访问外网 (curl https://www.google.com/generate_204) ..."
  if timeout 8 curl -sS -o /dev/null -w "%{http_code}\n" https://www.google.com/generate_204 | grep -qE '204|200'; then
    ok "Google 204 检查通过。"
  else
    err "Google 检查失败（可能被墙/被拦截），尝试 Cloudflare ..."
    if timeout 8 curl -sS -o /dev/null -w "%{http_code}\n" https://cloudflare.com/cdn-cgi/trace | grep -qE '200|301|302'; then
      ok "Cloudflare 检查通过。"
    else
      err "Cloudflare 检查失败。"
    fi
  fi

  echo "[3/3] 显示出口 IP（httpbin.org/ip） ..."
  timeout 8 curl -sS https://httpbin.org/ip || true
  set -e
}

healthcheck(){
  local gw newgw
  gw="$(detect_win_ip || true)"

  # If gateway changed (common after WSL network reset), rewrite config
  if [[ -n "$gw" ]]; then
    if ! grep -q "ip = ${gw};" "${REDSOCKS_CONF}" 2>/dev/null; then
      sed -i "s/^ *ip = .*/    ip = ${gw};/g" "${REDSOCKS_CONF}" || true
      echo "[health] 检测到 Windows IP 变化 -> ${gw}，已更新 redsocks.conf"
      systemctl try-reload-or-restart redsocks.service 2>/dev/null || pkill -HUP redsocks 2>/dev/null || true
      "$0" iptables-flush || true
      "$0" iptables-apply || true
    fi
  fi

  # Lightweight reachability test; if failed, restart components
  if ! timeout 3 bash -c "cat < /dev/null > /dev/tcp/${gw}/${PROXY_PORT}" 2>/dev/null; then
    echo "[health] 上游端口不可达，尝试重启 redsocks 与规则..."
    systemctl try-reload-or-restart redsocks.service 2>/dev/null || pkill -HUP redsocks 2>/dev/null || true
    "$0" iptables-flush || true
    "$0" iptables-apply || true
  fi
}

case "${1:-}" in
  start) start_service ;;
  stop) stop_service ;;
  restart) stop_service; start_service ;;
  status) status ;;
  test) test_conn ;;
  iptables-apply) apply_rules ;;
  iptables-flush) flush_rules ;;
  healthcheck) healthcheck ;;
  uninstall)
    "$0" stop || true
    rm -f "$ENV_FILE" "/usr/local/bin/proxyctl" "/etc/profile.d/wsl-proxy-aliases.sh"
    systemctl disable redsocks-iptables.service redsocks.service wsl-mtu.service wsl-proxy-health.timer >/dev/null 2>&1 || true
    rm -f /etc/systemd/system/redsocks-iptables.service /etc/systemd/system/redsocks.service /etc/systemd/system/wsl-mtu.service /etc/systemd/system/wsl-proxy-health.service /etc/systemd/system/wsl-proxy-health.timer
    ok "基础文件已移除（如需彻底清理，请手动 apt purge redsocks）。"
    ;;
  *) echo "用法: proxyctl {start|stop|restart|status|test|healthcheck|iptables-apply|iptables-flush|uninstall}"; exit 1 ;;
esac
EOF
  chmod +x /usr/local/bin/proxyctl
}

set_mtu_now() {
  local iface; iface="$(get_default_if || true)"
  if [[ -n "$iface" ]]; then
    ip link set dev "$iface" mtu "$MTU_VALUE" || true
    ok "已将 ${iface} 的 MTU 设为 ${MTU_VALUE}（开机由 systemd 持久设置）。"
  else
    warn "未能检测默认网卡，跳过即时 MTU 设置。"
  fi
}

#========================
# INSTALL / ACTIONS
#========================
usage() {
cat <<'USAGE'
用法：
  sudo bash wsl2-transparent-proxy.sh [install|start|stop|restart|status|test|uninstall]
可选环境变量：
  PROXY_TYPE=socks5|http-connect|http-relay|socks4  (默认 socks5)
  PROXY_PORT=2080                                   (默认 2080)
  REDSOCKS_LISTEN_PORT=31338                        (默认 31338)
  MTU_VALUE=1400                                    (默认 1400)
  EXTRA_BYPASS_CIDRS="..."                          (额外旁路网段)
示例：
  PROXY_TYPE=http-connect PROXY_PORT=2080 sudo -E bash wsl2-transparent-proxy.sh install
USAGE
}

do_install() {
  need_root "$@"

  info "步骤 1/8 安装依赖..."
  ensure_pkg redsocks iptables curl iproute2 netcat-openbsd

  info "步骤 2/8 创建系统用户/组与环境文件..."
  ensure_user_group
  write_env_file

  info "步骤 3/8 生成 redsocks 配置..."
  local win_ip; win_ip="$(get_windows_ip)"
  if [[ -z "$win_ip" ]]; then
    err "无法自动检测 Windows 主机 IP（默认网关）。请检查 WSL 网络。"
    exit 1
  fi
  make_redsocks_conf "$win_ip"
  ok "redsocks.conf 已写入（上游 ${PROXY_TYPE}://${win_ip}:${PROXY_PORT}）。"

  info "步骤 4/8 安装 proxyctl 管理命令与别名..."
  install_proxyctl
  make_aliases
  ok "已安装 /usr/local/bin/proxyctl 与中文/英文别名（重新登录 shell 生效）。"

  if detect_systemd; then
    info "步骤 5/8 安装并启用 systemd 单元（redsocks / iptables / mtu / 健康检查）..."
    install_systemd_units
  else
    warn "未检测到 systemd（/sbin/init 不是 systemd）。建议在 /etc/wsl.conf 中启用："
    echo -e "[boot]\nsystemd=true"
    warn "在未启用 systemd 的情况下，仍可用 proxyctl 手动 start/stop，但开机自启与定时自检不可用。"
  fi

  info "步骤 6/8 立即设置 MTU=${MTU_VALUE} ..."
  set_mtu_now

  info "步骤 7/8 启动服务并应用规则..."
  /usr/local/bin/proxyctl start

  info "步骤 8/8 运行连通性测试..."
  /usr/local/bin/proxyctl test

  ok "安装完成！使用 'proxyctl status' 查看状态。"
}

case "${1:-install}" in
  -h|--help|help) usage ;;
  install) do_install ;;
  start|stop|restart|status|test|uninstall)
    need_root "$@"
    /usr/local/bin/proxyctl "$1"
    ;;
  *)
    usage; exit 1 ;;
esac
